## 浏览器原理

### GPU
渲染图形图像处理器

### 进程 线程
进程 可以把看做一个应用程序
线程 进程 包含一个或者多个线程

### 浏览器架构

Browser Process 负责浏览器主体得分，包含导航栏 书签 前进 后退
Network 网络进程 负责页面的网络资源加载
GPU 图像渲染进程 不同 tab是有不同渲染进程 GPU需要接受这些进程请求 并且绘制页面
Renderer（多个）：渲染进程 标签页内和网页展示相关的所有工作 html css js 转换为用户可以交互的网页 默认情况下 每个tab 有一个独立的渲染进程
Plugin： 插件进程
其他进程：工具进程，辅助框架

### 多进程的优点

1. 容错性

2. 安全性 沙盒性

浏览器不希望用户可以拥有太多修改底层逻辑的能力，而用户多代码其实是跑在渲染进程里面，所以浏览器需要限制渲染进程的能力

3. 每个进程可以拥有更多的内存

因为每个进程都会分配一块独立的内存空间

### 多进程架构的坏处

公共的东西，会在不同的进程内存空间中存在，就会消耗了不必要内存空间

- Chrome优化

限制启动进程数目，当启用的进程达到上限后，访问同一个域名的 tab 都会放在一个进程里面

- Chrome 服务化
当 某些大的服务 拆分成小服务的模块，性能好的设备时候，每个服务可以独立的进程，保证系统的稳定性，当遇到性能不好的设备时，这些服务会被集中在晋城里面，减少内存消耗

### 网站隔离

iframe

当一个 tab 页面存在跨站的 iframe  那么 这个iframe 会拥有独立的渲染进程

b.com
iframe.a.com

### 导航时候发生了什么

1. url 解析
2. dns解析
3. tcp 链接
4. 发送http 请求
5. 接收 http 响应请求
6. 页面渲染
    1. 解析html 构建dom 树
    2. 解析 css 构建css规则树
    3. 合并 dom 树和 css 树规则 生成render树
    4. 布局 render 树
    5. 绘制 render 树
    6. 浏览器将各层的信息发送给GPU，GPU将各层合成，显示在屏幕上

### 处理输入

UI 线程 来判断关键词还是 url

### 开始导航

回车键 UI线程会通知网络进程初始化一个网络请求，来获取站点内容

- 301 永远重定向 网络进程 通知 ui线程进行重定向，然后再发起一个网络请求

- DNS 查询是在哪里做的

网络进程，在收到 UI 线程的通知后开始做的

### 读取响应

1. 响应类型多判断

Content-Type：application/json

2. 不同响应类型处理

* html，浏览器会讲获取到的数据交给渲染进程
* 压缩文件/其他类型，交给下载管理器来处理

3. 安全检查

比如检车是否和已知病毒页面匹配，或者检查处理跨站请求

### 寻找一个渲染进程来绘制页面

网络请求多耗时是不固定的，或许更长 UI线程做什么

在网络请求过程中，UI线程会提前创建一个渲染进程做准备

* 如果一切顺利，那么就直接用这个渲染进程
* 如果发生重定向或者安全问题，那么准备好的这个渲染进程会被舍弃掉，重新开启一个渲染进程


### 提交导航

HTML 开始渲染

### 加载完成

渲染进程 加载资源 渲染页面

当渲染进程完成渲染，load 会通过IPC告诉浏览器进程。让 UI 线程停止导航栏 tab 上的 转圈

### 渲染进程中具体做了什么

1. 构建DOM

渲染进程接受 html 文本教程，并且吧他转换成为 dom 对象

```html
Hi<b>Im <i>Chrome</b></i>
```


2. 加载子资源

解析dom 树木

3. js 会阻赛HTML解析过程

```html
会转向加载执行 js 代码的加载解析和执行
<script></script>
```

样式 布局 绘制 三部曲

### 样式计算

主线程解析页面的 css 来确定 每个 dom 节点的计算掩饰 computed style

### 布局 layout

1. 主线程会遍历构建的 dom 树，根据 dom 节点 的计算属性样式来计算出一个布局树
2. 布局树上的每个节点会在它的页面上的 x，y坐标 以及 盒子大小的具体信息

display：none 不会布局树上
visibility：hidden 会在树上

回流 重排

### 回流触发

添加删除元素，修改元素的大小，浏览器窗口的变化，获取 offsetTop clientHeight scrollTop getComputedStyle

### 优化操作

1. animation 不使用 left top 使用 transform 
2. 


由于每次重排/回流 都会造成额外的小号，所以大多数浏览器都会通过队列化修改来批量执行优化重排

[a,b,c, ....]

offsetTop 执行 将队列里面的触发重排回流的队列清空 获取 最新的内容 所以会触发重排回流

浏览器不得不清空队列，触发回流重绘来返回正确的值

### 绘制

z-index

回流 一定会导致 重绘

一次性插入 1W 条数据 window.requestAnimation  1帧插入 10条 递归调用

