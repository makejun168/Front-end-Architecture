### 报文结构

TCP 在实际要传输的数据之前附加了一个 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等等。

有了这个附加的 TCP 头，数据包才能够正确传输，到了目的地后把头部去掉，就可以拿到真正的数据

![img_7.png](img_7.png)

HTTP 也需要在实际传输的数据前附加一些头数据，不过是“纯文本”的协议，所以头数据都是 ASCII 码的文本，肉眼可读，不需要解析就能懂

HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：

1. 起始行（start line）：描述请求或响应的基本信息
2. 头部字段集合（header）：使用 key-value 形式更详细地说明报文
3. 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据

HTTP 协议规定报文必须有 header，但可以没有 body，而且 header 之后必须要有一个“空行”，也就是“CRLF”

![img_8.png](img_8.png)

Wireshark 抓包：

![img_9.png](img_9.png)


### 请求行

请求行，描述了客户端想要如何操作服务器端的资源

请求行由三部分构成：

1. 请求方法：是一个动词，如 GET/POST，表示对资源的操作
2. 请求目标：通常是一个 URI，标记了请求方法要操作的资源
3. 版本号：表示报文使用的 HTTP 协议版本

这三部分通常用空格（space）来分割，最后用 CRLF 换行表示结束

![img_10.png](img_10.png)

```
GET / HTTP/1.1
```

在以上例子，“GET”是请求方法，“/”是请求目标，"HTTP/1.1"是版本号，连接起来的意思是“服务器，我想要获取网站根目录下的默认文件，用的是 HTTP/1.1 版本”

### 状态行

响应报文的起始行，叫“状态行（status line）”，意思是服务器响应的状态

同样是三部分构成：

1. 版本号：表示报文使用的 HTTP 协议版本
2. 状态码：一个三位数，用代码的姓氏表示处理的结果，比如 200 是成功，500 是服务器内部错误
3. 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因

![img_11.png](img_11.png)

```
HTTP/1.1 200 OK
```

用通俗的话翻译过来的意思是，“已经处理完你的请求，这个报文使用协议版本号是 1.1，状态码是 200，一切 OK”

### 头部字段

以下是请求行和状态行加上头部字段的集合，构成的 HTTP 报文里完整的请求头和响应头：

![img_12.png](img_12.png)

HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可。

不过头字段有以下几点需要注意：

1. 字段名不区分大小写，例如“Host”等于“host”，首字母大写可读性更强
2. 字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名
3. 字段名后必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格
4. 字段的顺序是没有意义的，可以任意排列不影响语义
5. 字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie

### 常用头字段

HTTP 协议规定了非常多的头部字段，但基本上可以分为四大类：

通用字段：在请求头和响应头里可以出现
请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件
响应字段：仅能出现在响应头里，补充说明响应报文的信息
实体字段：它实际上属于通用字段，但专门描述 body 的额外信息

几个基本的头字段：

* Host： 
  * 请求字段，只能出现在请求头里，在 HTTP/1.1 规范里要求必须出现的字段。
  * Host 字段告诉服务器请求应该由哪个主机来处理

* User-Agent： 
  * 请求字段，只出现在请求头里，使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以一句他来返回最适合此浏览器显示的页面 
  * 有时候，不能通过 User-Agent 判断是哪一款浏览器。不过有时候，“诚实”的爬虫会在 User-Agent 里用“spider”表明自己是爬虫，所以可以利用这个字段实现简单的反爬虫策略

* Date： 
  * 通用字段，通常出现在响应头，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略

* Server： 
  * 响应字段，只能出现在响应头李，告诉客户端当前正在提供 Web 服务的软件名称和版本号，例如在我们的实验环境里它就是“Server: openresty/1.15.8.1”，即使用的是 OpenResty 1.15.8.1。

* Content-Length： 
  * 表示报文里，请求头或响应头空行后数据的长度，也就是 body 的长度。服务器看到这个字段，就知道后续有多少数据，可以直接接收。如果没有这个字段，body 就是不定长，需要使用 chuncked 方式分段传输

1. HTTP 报文结构由“起始行 + 头部 + 空行 + 实体”组成，简单地说就是“header + body”
2. HTTP 报文可以没有 body，但必须要有 header，而且 header 后也必须要有空行
3. 请求头由“请求行 + 头部字段”构成，响应头由“状态行 + 头部字段”构成
4. 请求行有三部分：请求方法、请求目标和版本号
5. 状态行有三部分：版本号、状态码和原因字符串
6. 头部字段是 key-value 形式，用“:”分隔，不区分大小写，顺序任意，除了规定的标准头，也可以任意添加自定义字段，实现功能扩展
7. HTTP/1.1 里唯一要求必须提供的头字段是 Host，它必须出现在请求头里，标记虚拟主机名


