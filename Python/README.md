# Python 学习记录

### 环境搭建

可以在[Python官方网站](https://www.python.org)下载到Python的Windows安装程序（exe文件），需要注意的是如果在Windows 7环境下安装需要先安装Service Pack 1补丁包（可以通过一些工具软件自动安装系统补丁的功能来安装），安装过程建议勾选“Add Python 3.6 to PATH”（将Python 3.6添加到PATH环境变量）并选择自定义安装，在设置“Optional Features”界面最好将“pip”、“tcl/tk”、“Python test 
suite”等项全部勾选上。
强烈建议使用自定义的安装路径并保证路径中没有中文。
安装完成会看到“Setup was successful”的提示，但是在启动Python环境时可能会因为缺失一些动态链接库文件而导致Python解释器无法运行，常见的问题主要是api-ms-win-crt\*.dll缺失以及更新DirectX之后导致某些动态链接库文件缺失，前者可以参照[《api-ms-win-crt\*.dll缺失原因分析和解决方法》]()一文讲解的方法进行处理或者直接在[微软官网](https://www.microsoft.com/zh-cn/download/details.aspx?id=48145)下载Visual C++ 
Redistributable for Visual Studio 2015文件进行修复，后者可以下载一个DirectX修复工具进行修复。

### 变量和类型

#### 1. 数据类型
- 整型：Python中可以处理任意大小的整数（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如`0b100`，换算成十进制是4）、八进制（如`0o100`，换算成十进制是64）、十进制（`100`）和十六进制（`0x100`，换算成十进制是256）的表示法。
- 浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如`123.456`）之外还支持科学计数法（如`1.23456e2`）。
- 字符串型：字符串是以单引号或双引号括起来的任意文本，比如`'hello'`和`"hello"`,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。
- 布尔型：布尔值只有`True`、`False`两种值，要么是`True`，要么是`False`，在Python中，可以直接用`True`、`False`表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如`3 < 5`会产生布尔值`True`，而`2 == 1`会产生布尔值`False`）
- 复数型：形如`3+5j`，跟数学上的复数表示一样，唯一不同的是虚部的`i`换成了`j`。

#### 2. 数据类型

* int 整型
* float 浮点型
* complex 复合型
* str 字符串型
* bool 布尔型

#### 3. Python 3 数据类型

* Number（数字）
* String（字符串）
* List（列表）
* Tuple（元组）
* Set（集合）
* Dictionary（字典）

> 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；
> 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。

#### 3.1 Number

Python3 支持 int、float、bool、complex（复数）。  
在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。  
像大多数语言一样，数值类型的赋值和计算都是很直观的。内置的 type() 函数可以用来查询变量所指的对象类型。


#### 变量命名

* 硬性规则：
* 变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头。  
* 大小写敏感（大写的`a`和小写的`A`是两个不同的变量）。  
* 不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。- PEP 8要求：  
* 用小写字母拼写，多个单词用下划线连接。
* 受保护的实例属性用单个下划线开头
* 私有的实例属性用两个下划线开头

#### 运算符
下表大致按照优先级从高到低的顺序列出了所有的运算符  

| 运算符                                                       | 描述 |
| ------------------------------------------------------------ | ------------------------------ |
| `[]` `[:]`                                                   | 下标，切片                     |
| `**`                                                         | 指数                           |
| `~` `+` `-`                                                  | 按位取反, 正负号             |
| `*` `/` `%` `//`                                             | 乘，除，模，整除             |
| `+` `-`                                                      | 加，减                         |
| `>>` `<<`                                                    | 右移，左移                  |
| `&`                                                          | 按位与                         |
| `^` `\|`                                                      | 按位异或，按位或            |
| `<=` `<` `>` `>=`                                            | 小于等于，小于，大于，大于等于 |
| `==` `!=`                                                    | 等于，不等于                   |
| `is` `is not`                                               | 身份运算符                     |
| `in` `not in`                                                | 成员运算符                     |
| `not` `or` `and`                                             | 逻辑运算符                     |
| `=` `+=` `-=` `*=` `/=` `%=` `//=` `**=` `&=` `\|=` `^=` `>>=` `<<=` | （复合）赋值运算符 |

#### 算术运算符

| 运算符 | 描述 | 实例 |
| --- | --- | --- |
| + | 加 - 两个对象相加 | a + b 输出结果 30 |
| - | 减 - 两个对象相减 | a - b 输出结果 30 |
| * | 乘 - 两个数字相乘 | a * b 输出结果 30 |
| / | 除 - 两个数字相除 | a / b 输出结果 30  |
| % | 取模 - 返回除法的余数 | 12 % 7 = 5 |
| ** | 幂 - 返回x的y次幂 | 3 ** 3 = 27 |
| // | 整除 - 两个数整除的结构 | 9 // 2 => 4 |

#### 逻辑运算符
| 运算符 | 描述 | 实例 |
| --- | --- | --- |
| == | 等于 - 比较对象是否相等 | (a == b) 返回 False |
| != | 不等于 - 比较两个对象是否不相等 | (a != b) 返回 true |
| <> | 不等于 - 比较两个对象是否不相等 | (a <> b) 返回 true。这个运算符类似 != |
| > | 大于 - 返回x是否大于y | (a > b) 返回 False |
| < | 小于 - 返回x是否小于y 所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价 | (a < b) 返回 true |
| >= | 大于等于 - 返回x是否大于等于y | (a >= b) 返回 False |
| <= | 小于等于 - 返回x是否小于等于y | (a <= b) 返回 true |

### 分支结构

#### 分支结构的应用场景
 游戏中的分支结构场景，比如进入某个场景之前选择一个方向
```Python
direction = int(input('请输入方向 '))
if direction == 0:
    print('进入场景1')
elif direction == 1:
    print('进入场景2')
elif direction == 2:
    print('进入场景3')
else:
    print('进入默认场景4')
```

#### if语句的使用
在Python中，要构造分支结构可以使用`if`、`elif`和`else`关键字。所谓关键字就是有特殊含义的单词，像`if`和`else`就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名（事实上，用作其他的标识符也是不可以）。下面的例子中演示了如何构造一个分支结构。

#### 使用缩进来设置代码结构

唯一需要说明的是和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果`if`条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于是一个执行的整体。



### 循环结构

#### 循环结构的应用场景

如果在程序中我们需要重复的执行某条或某些指令，例如用程序控制机器人踢足球，如果机器人持球而且还没有进入射门范围，那么我们就要一直发出让机器人向球门方向奔跑的指令。当然你可能已经注意到了，刚才的描述中其实不仅仅有需要重复的动作，还有我们上一个章节讲到的分支结构。再举一个简单的例子，比如在我们的程序中要实现每隔1秒中在屏幕上打印一个"hello, world"这样的字符串并持续一个小时，我们肯定不能够将print('hello, world')这句代码写上3600遍，如果真的需要这样做那么编程的工作就太无聊了。因此，我们需要了解一下循环结构，有了循环结构我们就可以轻松的控制某件事或者某些事重复、重复、再重复的发生。在Python中构造循环结构有两种做法，一种是for-in循环，一种是while循环。

##### 1. for-in 循环
如果明确的知道循环执行的次数或者是要对一个容器进行迭代（后面会讲到），那么我们推荐使用`for-in`循环

* 循环列表的中键值对
```Python
for key, value in Obj:
    print('key：%s' % key)
    print('value：%d' % value)
```
* range 需要说明的是上面代码中的`range`类型，`range`可以用来产生一个不变的数值序列，而且这个序列通常都是用在循环中的
    - `range(101)`
        - 可以产生一个0到100的整数序列。
    - `range(1, 100)`
        -  可以产生一个1到99的整数序列。
    - `range(1, 100, 2)`
        - 可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。


##### 2. While 循环
如果要构造不知道具体循环次数的循环结构，我们推荐使用`while`循环，`while`循环通过一个能够产生或转换出`bool`值的表达式来控制循环，表达式的值为`True`循环继续，表达式的值为`False`循环结束。下面我们通过一个“猜数字”的小游戏（计算机出一个1~100之间的随机数，人输入自己猜的数字，计算机给出对应的提示信息，直到人猜出计算机出的数字）

##### 3. 运算语法 整除
Python 2.2：
```Python
from __future__ import division
```
> " / "就表示 浮点数除法，返回浮点结果;" // "表示整数除法。


Python 3以后：
> " / "就表示 浮点数除法，返回浮点结果;" // "表示整数除法。


#### Python的内置函数
##### 1. 数学相关
- 数学相关: abs / divmod / pow / round / min / max / sum / cmp .... 还有部分

| 方法 | 语法 |描述 | 实例 |
| --- | --- | --- |  --- |
| abs | abs(x) | 绝对值 | abs(-1.2345) = 1.2345 |
| round | round(x [, n]) | round() 方法返回浮点数x的四舍五入值 | round(80.23456, 2) :  80.23 |
| pow | pow(x, y[, z]) | 函数是计算x的y次方，如果z在存在，则再对结果进行取模，其结果等效于pow(x,y) %z | pow(2, 3) = 8 |
| divmod | divmod(a, b) | 把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b) | divmod(7, 2) = (3, 1) |
| min | min( x, y, z, .... ) | min() 方法返回给定参数的最小值，参数可以为序列 | min(80, 100, 1000) = 80 |
| max | max( x, y, z, .... ) | max() 方法返回给定参数的最大值，参数可以为序列 | max(80, 1000, 2000, .... ) = 2000 |
| sum | sum(iterable[, start]) | sum() 方法对系列进行求和计算 | sum([0, 1, 2]) = 3 |
| cmp | cmp(x, y) | cmp(x,y) 函数用于比较2个对象，如果 x < y 返回 -1, 如果 x == y 返回 0, 如果 x > y 返回 1 | cmp(80, 100) |

注意：sum 可以传 列表、元组、集合作为参数进行计算
注意：pow() 通过内置的方法直接调用，内置方法会把参数作为整型，而 math 模块则会把参数转换为 float。

##### 2. 序列相关
- 序列相关: len / range / next / filter / map / sorted / slice / reversed

| 方法 | 语法 |描述 | 实例 |
| --- | --- | --- |  --- |
| slice | slice(start, stop) | slice() 函数实现切片对象，主要用在切片操作函数里的参数传递 | [0, 1, 2, 3, 4, 5][slice(2)] = [0, 1] |
| len | len( s ) | len() 方法返回对象（字符、列表、元组等）长度或项目个数 | len('orange') = 6 |
| range | range(start, stop) | range() 函数可创建一个整数列表，一般用在 for 循环中 | range(1, 11) |
| next | next(iterator[, default]) | next() 返回迭代器的下一个项目 | next() 需要配合迭代器一起使用 |
| filter | filter(function, iterable) | filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中 | newlist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) |
| map | map(function, iterable, ...) |第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表 | map(lambda x: x ** 2, [1, 2, 3, 4, 5]) |
| sorted | sorted(iterable, cmp=None, key=None, reverse=False) | sorted() 函数对所有可迭代的对象进行排序操作 | L=[('b',2),('a',1),('c',3),('d',4)] >>> sorted(L, cmp=lambda x,y:cmp(x[1],y[1])) |
| reversed | reversed(seq) | reversed 函数返回一个反转的迭代器 | seqList = [1, 2, 4, 3, 5] print(list(reversed(seqList))) |

* iterable -- 可迭代对象
* cmp -- 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0
* key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。reverse -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）

##### 3. 类型转换
- chr / ord / str / bool / int / float / complex / bin / oct / hex

| 方法 | 语法 |描述 | 实例 |
| --- | --- | --- |  --- |
| chr | chr(i) | chr() 用一个范围在 range（256）内的（就是0～255）整数作参数，返回一个对应的字符 | chr(0x9a6c) = 马 |
| ord | ord(c) | ord() 函数是 chr() 函数（对于8位的ASCII字符串）或 unichr() 函数（对于Unicode对象）的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值，如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常 | ord('a') 97 |
| str | str(object) | str() 函数将对象转化为适于人阅读的形式 | dict = {'runoob': 'runoob.com', 'google': 'google.com'}; >>> str(dict) |
| bool | bool() | bool() 函数用于将给定参数转换为布尔类型，如果没有参数，返回 False。bool 是 int 的子类 | bool(0) False >>> bool(1) True |
| int | int(x, base=10) | int() 函数用于将一个字符串或数字转换为整型 | int(3.6) >>> 3  int('12',16) >>> 18 |
| float | float([x]) | float() 函数用于将整数和字符串转换成浮点数 | float(-123.6) -123.6 >>> float('123') >>> 123.0 |
| complex | complex([real[, imag]]) | complex() 函数用于创建一个值为 real + imag * j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数 | complex(1, 2) (1 + 2j) |
| bin | bin(x) | bin() 返回一个整数 int 或者长整数 long int 的二进制表示 | bin(10) >>> '0b1010' |
| oct | oct(x) | oct() 函数用于将10进制整数转换成8进制字符串，以字符串形式表示 | oct(x) >>> '012' |
| hex | hex)(x) | hex() 函数用于将10进制整数转换成16进制，以字符串形式表示 | hex(255) >>> '0xff' |

* 注意：这个地方在"+"号两边不能有空格，也就是不能写成"1 + 2j"，应该是"1+2j"，否则会报错 >>> complex("1+2j") (1 + 2j)

##### 4. 数据结构
- dict / list / set / tuple 

| 方法 | 语法 |描述 | 实例 |
| --- | --- | --- |  --- |
| list | list(tup) | list() 方法用于将元组转换为列表 | list2 = [1, 2, 3, 4, 5, 6, 7 ] list2[1:5]:  [2, 3, 4, 5] |
| dict | dict(iterable, kwarg) | dict() 函数用于创建一个字典 | dict([('one', 1), ('two', 2), ('three', 3)]) # 可迭代对象方式来构造字典 {'three': 3, 'two': 2, 'one': 1} |
| set | set([iterable])  | set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等 | x = set('runoob') >>> y = set('google') x, y (set(['b', 'r', 'u', 'o', 'n']), set(['e', 'o', 'g', 'l'])) |
| tuple | tuple( seq ) | Python 元组 tuple() 函数将列表转换为元组 | tuple([1,2,3,4]) (1, 2, 3, 4) |

* 元组和列表都可以进行遍历 list() tuple() 列表元组进行互相转换
* 元组与列表是非常类似的，区别在于元组的元素值不能修改，元组是放在括号中，列表是放于方括号中

#### 字符串和常用数据结构

> 这段代码的主要作用主要是让该python文件既可以独立运行，也可以当做模块导入到其他文件。当导入到其他的脚本文件的时候，此时__name__的名字其实是导入模块的名字，不是’__main__’, main代码里面的就不执行了
```

if __name__ == '__main__':
    statements
```





## 面向对象编程基础

### 类和对象

简单的说，类是对象的蓝图和模板，而对象是类的实例。这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。当我们把一大堆拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做“类”的东西。


### 定义类
在Python中可以使用`class`关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来


```Python
class Student(object):
# __init__是一个特殊方法用于在创建对象时进行初始化操作
# 通过这个方法我们可以为学生对象绑定name和age两个属性
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def study(self, course_name):
        print('%s正在学习%s.' % (self.name, course_name))
        # PEP 8要求标识符的名字用全小写多个单词用下划线连接
        # 但是很多程序员和公司更倾向于使用驼峰命名法(驼峰标识)
    def watch_av(self):
        if self.age < 18:
            print('%s只能观看《熊出没》.' % self.name)
        else:
            print('%s正在观看岛国爱情动作片.' % self.name)                   

def main():
# 创建学生对象并指定姓名和年龄
    stu1 = Student('骆昊', 38)
# 给对象发study消息
    stu1.study('Python程序设计')
# 给对象发watch_av消息
    stu1.watch_av()
    stu2 = Student('王大锤', 15)
    stu2.study('思想品德')
    stu2.watch_av()
if __name__ == '__main__':
    main()
```

### 访问可见性问题
对于上面的代码，有C++、Java、C#等编程经验的程序员可能会问，我们给`Student`对象绑定的`name`和`age`属性到底具有怎样的访问权限（也称为可见性）。因为在很多面向对象编程语言中，我们通常会将对象的属性设置为私有的（private）或受保护的（protected），简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），因为公开的方法就是对象能够接受的消息。在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头，下面的代码可以验证这一点。

```Python
class Test:    
    def __init__(self, foo):        
        self.__foo = foo    
    def __bar(self):        
        print(self.__foo)        
        print('__bar')
    def main():    
        test = Test('hello')    
    # AttributeError: 'Test' object has no attribute '__bar'    test.__bar()    
    # AttributeError: 'Test' object has no attribute '__foo'    print(test.__foo)
        
```

但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来“妨碍”对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，就是“We are all consenting adults here”。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。

```Python
class Test:    
    def __init__(self, foo):        
        self.__foo = foo    
    def __bar(self):        
        print(self.__foo)        
        print('__bar')
    def main():    
        test = Test('hello')    
        test._Test__bar()    
        print(test._Test__foo)
        
if __name__ == "__main__":
    main()

```

### 面向对象的支柱

面向对象有三大支柱：封装、继承和多态。后面两个概念在下一个章节中进行详细的说明，这里我们先说一下什么是封装。我自己对封装的理解是“隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口”。我们在类中定义的方法其实就是把数据和对数据的操作封装起来了，在我们创建了对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的外部视图），而不需要知道方法内部的实现细节（方法的内部视图）。


## 面向对象编程进阶

### @property

```Python

@age.setter
```

虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便

### __slots__

```Python
__slots__ = ('_name', '_age', '_gender')
```

Python是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用（当前的类发生约束，子类不约束）

### 静态方法和类方法

实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题

```Python
@staticmethoddef 
is_valid(a, b, c):    
    return a + b > c and b + c > a and a + c > b
```

和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示。

### 类之间的关系

简单的说，类和类之间的关系有三种：
    is-a、has-a和use-a关系。
    is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。
    has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。
    use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。我们可以使用一种叫做UML（统一建模语言）的东西来进行面向对象建模，其中一项重要的工作就是把类和类之间的关系用标准化的图形符号描述出来。阅读《UML面向对象设计基础》。
    
利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常工作中都会使用到的技术手段

### 继承和多态

刚才我们提到了，可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为**里氏替换**原则。

```Python
class Teacher(Person):
# 传入Person 参数就可以
```

子类在继承了父类的方法后，子类可以对父类已有的方法给出新的实现版本，这个动作称之为方法**重写（override）**。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。子类的多样性就是多态
